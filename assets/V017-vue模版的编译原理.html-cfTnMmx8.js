import{_ as s,c as a,a as e,o as t}from"./app-KfnfuIf0.js";const p={};function l(c,n){return t(),a("div",null,[...n[0]||(n[0]=[e(`<h1 id="v017-vue-模版的编译原理" tabindex="-1"><a class="header-anchor" href="#v017-vue-模版的编译原理"><span>V017-vue 模版的编译原理</span></a></h1><h2 id="vue-模板编译原理" tabindex="-1"><a class="header-anchor" href="#vue-模板编译原理"><span>Vue 模板编译原理</span></a></h2><p>Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步</p><blockquote><p>第一步是将 模板字符串 转换成 element ASTs 语法树 （解析器） 第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器） 第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）</p></blockquote><p>相关代码如下</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span><span class="token parameter">template</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 我们需要把html字符串变成render函数</span></span>
<span class="line">  <span class="token comment">// 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法</span></span>
<span class="line">  <span class="token comment">// 很多库都运用到了ast 比如 webpack babel eslint等等</span></span>
<span class="line">  <span class="token keyword">let</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 2.优化静态节点</span></span>
<span class="line">  <span class="token comment">// 这个有兴趣的可以去看源码  不影响核心功能就不实现了</span></span>
<span class="line">  <span class="token comment">//   if (options.optimize !== false) {</span></span>
<span class="line">  <span class="token comment">//     optimize(ast, options);</span></span>
<span class="line">  <span class="token comment">//   }</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 3.通过ast 重新生成代码</span></span>
<span class="line">  <span class="token comment">// 我们最后生成的代码需要和render函数一样</span></span>
<span class="line">  <span class="token comment">// 类似_c(&#39;div&#39;,{id:&quot;app&quot;},_c(&#39;div&#39;,undefined,_v(&quot;hello&quot;+_s(name)),_c(&#39;span&#39;,undefined,_v(&quot;world&quot;))))</span></span>
<span class="line">  <span class="token comment">// _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本</span></span>
<span class="line">  <span class="token keyword">let</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">//   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值</span></span>
<span class="line">  <span class="token keyword">let</span> renderFn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">with(this){return </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">}</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> renderFn<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><blockquote><p>首先将 template 编译成 ast 语法树，ast 树形结构，不光可以描述 html 结构，也可以描述 css 样式，js 语法 对 ast 语法树，进行静态节点标记，静态节点不改变，不需要每次重新渲染 将 ast 语法树，生成 render 函数，render 函数返回 vnode，vnode 是一个 js 对象，描述 dom 节点的信息 最后将 vnode，转化为真实 dom 渲染到页面上</p></blockquote>`,8)])])}const o=s(p,[["render",l]]),r=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue%E7%AF%87/V017-vue%E6%A8%A1%E7%89%88%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.html","title":"V017-vue 模版的编译原理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1768183010000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"c3ab6d103d428cdd6a361e045add7154fc9253f1","time":1768183010000,"email":"yk4545945@163.com","author":"qdleader","message":"docs(mcp): 新增Mastergo MCP配置文档，包含token获取方法"}]},"filePathRelative":"前端面试/vue篇/V017-vue模版的编译原理.md"}');export{o as comp,r as data};
