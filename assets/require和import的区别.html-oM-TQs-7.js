import{_ as t,c as o,b as e,o as i}from"./app-KfnfuIf0.js";const m={};function a(p,r){return i(),o("div",null,[...r[0]||(r[0]=[e("h1",{id:"require-和import-的区别",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#require-和import-的区别"},[e("span",null,"require 和import 的区别？")])],-1),e("p",null,"require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，所以必须放在文件开头 import不能在函数、判断语句等代码块之中引用；require 可以。",-1),e("p",null,"require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用 通过require引入基础数据类型时，属于复制该变量。通过require引入复杂数据类型时，属于浅拷贝该对象。 import/export 不能对引入模块重新赋值/定义",-1),e("p",null,"import 是编译时运行的（require是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择import的接口进行编译，这样在性能上比require好很多。",-1),e("p",null,"两个阶段都采用深度优先遍历，执行顺序是子 -> 父。 import() 动态引入 import() 返回一个 Promise 对象， 返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息",-1),e("p",null,"import 是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require",-1)])])}const s=t(m,[["render",a]]),u=JSON.parse('{"path":"/es6/commonjs%E4%B8%8Eesmodule/require%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"require 和import 的区别？","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1768183010000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"c3ab6d103d428cdd6a361e045add7154fc9253f1","time":1768183010000,"email":"yk4545945@163.com","author":"qdleader","message":"docs(mcp): 新增Mastergo MCP配置文档，包含token获取方法"}]},"filePathRelative":"es6/commonjs与esmodule/require和import的区别.md"}');export{s as comp,u as data};
