import{_ as t,c as o,b as e,o as a}from"./app-D8HvJIFE.js";const n={};function l(d,r){return a(),o("div",null,[...r[0]||(r[0]=[e("h1",{id:"vue3为什么要用proxy替代defineproperty",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue3为什么要用proxy替代defineproperty"},[e("span",null,"vue3为什么要用Proxy替代defineProperty")])],-1),e("p",null,"vue2 中 采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式，但有以下问题",-1),e("blockquote",null,[e("p",null,"检测不到对象属性的添加和删除 数组API 无法监听到（ 无法监听数组基于下标的修改） 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题 对 Map、Set、WeakMap 和 WeakSet 不支持；")],-1),e("p",null,"2、proxy： 监听是针对一个对象的，那么对于这个对象的所有操作会进入监听操作",-1),e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结"},[e("span",null,"总结")])],-1),e("blockquote",null,[e("p",null,"Object.defineProperty 只能遍历对象属性进行劫持 Proxy 可以直接劫持整个对象，并返回一个新的对象，我们可以只操作新的对象达到响应式目的 Proxy 可以直接监听数组的变化(push、 shift、splice) Proxy 有多达13种拦截方法，不限于apply、ownkeys、deleteProperty、has等等，这个是Object.defineProperty 不具备的")],-1)])])}const s=t(n,[["render",l]]),i=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue3%E7%AF%87/vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Proxy%E6%9B%BF%E4%BB%A3defineProperty.html","title":"vue3为什么要用Proxy替代defineProperty","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"前端面试/vue3篇/vue3为什么要用Proxy替代defineProperty.md"}');export{s as comp,i as data};
