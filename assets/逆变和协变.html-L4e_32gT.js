import{_ as n,c as a,a as e,o as p}from"./app-D8HvJIFE.js";const t={};function l(o,s){return p(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="逆变和协变" tabindex="-1"><a class="header-anchor" href="#逆变和协变"><span>逆变和协变</span></a></h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h2><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line">协变：类型推导到其子类型的过程，<span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span> 就是一个协变</span>
<span class="line">逆变：类型推导到其超类型的过程</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何判断函数子类型" tabindex="-1"><a class="header-anchor" href="#如何判断函数子类型"><span>如何判断函数子类型？</span></a></h2><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line">为了方便描述，「Dog <span class="token operator">=&gt;</span> Dog」 表示「参数为 Dog，返回值为 Dog 的函数」</span>
<span class="line">其他类型的子类型我们很好判断，函数的子类型却很难，比如有关系 Animal <span class="token operator">-</span><span class="token operator">&gt;</span> Dog <span class="token operator">-</span><span class="token operator">&gt;</span> Shepherd</span>
<span class="line"></span>
<span class="line">Animal <span class="token operator">=&gt;</span> Shepherd 是  Dog <span class="token operator">=&gt;</span> Dog 子类型吗？</span>
<span class="line">是的</span>
<span class="line"></span>
<span class="line">我们如果把视角划分，Dog <span class="token operator">=&gt;</span> Dog  作为</span>
<span class="line">参数的传入者：只能保证传入 Dog 参数，所以当我们定义参数为 Animal 时，只能使用 Animal 上的属性和方法，而 Dog 肯定有，就能保证类型的正确。</span>
<span class="line">使用返回值者：保证只使用 Dog 方法，所以当我们定义返回值为 Shepherd，使用者只使用 Dog 上的属性和方法，而 Shepherd 肯定有，就能保证类型的正确。</span>
<span class="line">所以，Dog <span class="token operator">=&gt;</span> Dog  <span class="token operator">-</span><span class="token operator">&gt;</span> Animal <span class="token operator">=&gt;</span> Shepherd</span>
<span class="line">也称 参数是逆变的，返回值是协变的。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">至于你为什么这么少看到协变和逆变的概念，只因为 TypeScript 只有一处逆变，就是参数</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例：</p><h4 id="协变" tabindex="-1"><a class="header-anchor" href="#协变"><span>协变</span></a></h4><h5 id="covariance" tabindex="-1"><a class="header-anchor" href="#covariance"><span>Covariance</span></a></h5><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line">如果<span class="token constant">T</span> ≤ <span class="token constant">U</span>，那么<span class="token constant">F</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> ≤ <span class="token constant">F</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span>也成立，这就叫协变。很容易理解吧。</span>
<span class="line">这里协变主要讲函数的返回值类型的检查。</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">Co<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">V</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Co&lt;Dog&gt; ≤ Co&lt;Animal&gt;</span></span>
<span class="line"><span class="token keyword">const</span> animalFn<span class="token operator">:</span> Co<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> dogFn<span class="token operator">:</span> Co<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> a<span class="token operator">:</span> Co<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> dogFn<span class="token punctuation">;</span> <span class="token comment">// ok，dogFn返回Dog，Dog本身就是Animal</span></span>
<span class="line"><span class="token keyword">let</span> b<span class="token operator">:</span> Co<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token operator">=</span> animalFn<span class="token punctuation">;</span> <span class="token comment">// error，animalFn返回Animal，Animal不一定是Dog，有可能不会doDogThing</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，函数的返回值类型要协变才安全，否则ts可能会报错。</p><h4 id="逆变" tabindex="-1"><a class="header-anchor" href="#逆变"><span>逆变</span></a></h4><h5 id="cotravariance" tabindex="-1"><a class="header-anchor" href="#cotravariance"><span>Cotravariance</span></a></h5><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line">跟协变相反，如果<span class="token constant">T</span> ≤ <span class="token constant">U</span>，那么<span class="token constant">F</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span> ≤ <span class="token constant">F</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>成立，这就叫逆变。</span>
<span class="line">这里逆变主要讲的是函数的参数类型的检查。</span>
<span class="line"></span>
<span class="line">注意，是函数赋值时对参数的检查，并不是参数赋值时的检查。</span>
<span class="line"></span>
<span class="line">当开启了<span class="token operator">--</span>strictFunctionTypes或者<span class="token operator">--</span>strict模式，ts才对函数参数类型进行逆变检查。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">Cotra<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token constant">V</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Cotra&lt;Animal&gt; ≤ Cotra&lt;Dog&gt;</span></span>
<span class="line"><span class="token keyword">const</span> animalFn<span class="token operator">:</span> Cotra<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  input<span class="token punctuation">.</span><span class="token function">doAnimalThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> dogFn<span class="token operator">:</span> Cotra<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  input<span class="token punctuation">.</span><span class="token function">doDogThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> a<span class="token operator">:</span> Cotra<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> dogFn<span class="token punctuation">;</span> <span class="token comment">// error，Animal没有doDogThing方法</span></span>
<span class="line"><span class="token keyword">let</span> b<span class="token operator">:</span> Cotra<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token operator">=</span> animalFn<span class="token punctuation">;</span> <span class="token comment">// ok</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line">这里可能有点难理解，但是细想一下，就会发现这是合理的。</span>
<span class="line">方法a我们定义入参为一个Animal，但是赋值是dogFn，调用方法a时如果真的传入Animal，由于Animal没有doDogThing方法，一定会执行出错。所以这里ts会提示错误。</span>
<span class="line">但反过来就没问题。方法b传入Dog，Dog继承Animal，是有doAnimalThing方法的。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16)])])}const i=n(t,[["render",l]]),r=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/TS%E7%AF%87/%E8%BF%9B%E9%98%B6%E7%AF%87/%E9%80%86%E5%8F%98%E5%92%8C%E5%8D%8F%E5%8F%98.html","title":"逆变和协变","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"前端面试/TS篇/进阶篇/逆变和协变.md"}');export{i as comp,r as data};
