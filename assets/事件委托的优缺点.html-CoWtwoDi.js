import{_ as e,c as t,a as o,o as s}from"./app-D8HvJIFE.js";const c={};function d(r,a){return s(),t("div",null,[...a[0]||(a[0]=[o('<h1 id="事件委托-事件代理-的原理以及优缺点是什么" tabindex="-1"><a class="header-anchor" href="#事件委托-事件代理-的原理以及优缺点是什么"><span>事件委托（事件代理）的原理以及优缺点是什么？</span></a></h1><h3 id="事件委托原理-事件冒泡机制" tabindex="-1"><a class="header-anchor" href="#事件委托原理-事件冒泡机制"><span>事件委托原理：事件冒泡机制；</span></a></h3><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点：</span></a></h2><blockquote><p>1、可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错； (a.每一个事件处理函数，都是一个对象，多一个事件处理函数，内存中就会被多占用一部分空间。如果要用事件委托，就会将所有的操作放到 js 程序里面，只对它的父级进行操作，与 dom 的操作就只需要交互一次，这样就能大大的减少与 dom 的交互次数，提高性能； 减少了内存占用, 性能更好; b.在访问 DOM 方面, 也使得 DOM 访问次数减少试想一下, 如果要为许多的 DOM 元素绑定事件, 自然需要多次访问 DOM 元素, 设置事件处理程序所需时间更长, 整个页面就绪需要的时间越多因此第二个优点是: 设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间)</p></blockquote><blockquote><p>2、可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为适合；</p></blockquote><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h2><blockquote><p>事件委托的实现依靠的冒泡，因此不支持事件冒泡的事件就不适合使用事件委托。 不是所有的事件绑定都适合使用事件委托，不恰当使用反而可能导致不需要绑定事件的元素也被绑定上了事件。</p></blockquote>',7)])])}const l=e(c,[["render",d]]),h=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/DOM%E7%B1%BB/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.html","title":"事件委托（事件代理）的原理以及优缺点是什么？","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"前端面试/js类/DOM类/事件委托的优缺点.md"}');export{l as comp,h as data};
