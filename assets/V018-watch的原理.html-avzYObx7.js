import{_ as t,c,b as e,o as d}from"./app-D8HvJIFE.js";const r={};function h(l,a){return d(),c("div",null,[...a[0]||(a[0]=[e("h1",{id:"v018-watch的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#v018-watch的原理"},[e("span",null,"V018-watch的原理")])],-1),e("h2",{id:"watch-的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#watch-的原理"},[e("span",null,"watch 的原理")])],-1),e("p",null,"watch 本质上是为每个监听属性 setter 创建了一个 watcher，当被监听的属性更新时，调用传入的回调函数。常见的配置选项有 deep 和 immediate，对应原理如下",-1),e("p",null,"• deep：深度监听对象，为对象的每一个属性创建一个 watcher，从而确保对象的每一个属性更新时都会触发传入的回调函数。主要原因在于对象属于引用类型，单个属性的更新并不会触发对象 setter，因此引入 deep 能够很好地解决监听对象的问题。同时也会引入判断机制，确保在多个属性更新时回调函数仅触发一次，避免性能浪费。",-1),e("p",null,"• immediate：在初始化时直接调用回调函数，可以通过在 created 阶段手动调用回调函数实现相同的效果",-1)])])}const s=t(r,[["render",h]]),o=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue%E7%AF%87/V018-watch%E7%9A%84%E5%8E%9F%E7%90%86.html","title":"V018-watch的原理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"前端面试/vue篇/V018-watch的原理.md"}');export{s as comp,o as data};
