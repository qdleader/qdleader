import{_ as a,c as r,a as s,o as d}from"./app-KfnfuIf0.js";const n={};function c(t,e){return d(),r("div",null,[...e[0]||(e[0]=[s('<h1 id="defer和async的区别" tabindex="-1"><a class="header-anchor" href="#defer和async的区别"><span>defer和async的区别</span></a></h1><h2 id="defer-延迟脚本" tabindex="-1"><a class="header-anchor" href="#defer-延迟脚本"><span>defer （延迟脚本）</span></a></h2><p>延迟脚本：defer 属性只适用于外部脚本文件。 如果给 script 标签定义了defer 属性，这个属性的作用是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，如果 script 元素中设置了 defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><h2 id="async-异步脚本" tabindex="-1"><a class="header-anchor" href="#async-异步脚本"><span>async（异步脚本）</span></a></h2><p>异步脚本：async 属性也只适用于外部脚本文件，并告诉浏览器立即下载文件。 但与 defer 不同的是：标记为 async 的脚本并不保证按照指定它们的先后顺序执行。 所以总结起来，两者之间最大的差异就是在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的。 defer 是立即下载但延迟执行，加载后续文档元素的过程将和脚本的加载并行进行（异步），但是脚本的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。async 是立即下载并执行，加载和渲染后续文档元素的过程将和 js 脚本的加载与执行并行进行（异步）。</p><p>简单来说就是 defer 和 async 都可以 将同步加载的文件变为异步，不会阻塞浏览器渲染了，defer是等所有别的元素解析完后执行，async 是立即执行，并且async 只能引入外部文件</p>',6)])])}const f=a(n,[["render",c]]),h=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/%E5%85%B6%E4%BB%96%E7%B1%BB/defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"defer和async的区别","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1768183010000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"c3ab6d103d428cdd6a361e045add7154fc9253f1","time":1768183010000,"email":"yk4545945@163.com","author":"qdleader","message":"docs(mcp): 新增Mastergo MCP配置文档，包含token获取方法"}]},"filePathRelative":"前端面试/js类/其他类/defer和async的区别.md"}');export{f as comp,h as data};
