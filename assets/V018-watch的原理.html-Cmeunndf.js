import{_ as t,c,b as e,o as r}from"./app-KfnfuIf0.js";const d={};function h(l,a){return r(),c("div",null,[...a[0]||(a[0]=[e("h1",{id:"v018-watch的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#v018-watch的原理"},[e("span",null,"V018-watch的原理")])],-1),e("h2",{id:"watch-的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#watch-的原理"},[e("span",null,"watch 的原理")])],-1),e("p",null,"watch 本质上是为每个监听属性 setter 创建了一个 watcher，当被监听的属性更新时，调用传入的回调函数。常见的配置选项有 deep 和 immediate，对应原理如下",-1),e("p",null,"• deep：深度监听对象，为对象的每一个属性创建一个 watcher，从而确保对象的每一个属性更新时都会触发传入的回调函数。主要原因在于对象属于引用类型，单个属性的更新并不会触发对象 setter，因此引入 deep 能够很好地解决监听对象的问题。同时也会引入判断机制，确保在多个属性更新时回调函数仅触发一次，避免性能浪费。",-1),e("p",null,"• immediate：在初始化时直接调用回调函数，可以通过在 created 阶段手动调用回调函数实现相同的效果",-1)])])}const s=t(d,[["render",h]]),o=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue%E7%AF%87/V018-watch%E7%9A%84%E5%8E%9F%E7%90%86.html","title":"V018-watch的原理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1768183010000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"c3ab6d103d428cdd6a361e045add7154fc9253f1","time":1768183010000,"email":"yk4545945@163.com","author":"qdleader","message":"docs(mcp): 新增Mastergo MCP配置文档，包含token获取方法"}]},"filePathRelative":"前端面试/vue篇/V018-watch的原理.md"}');export{s as comp,o as data};
