import{_ as a,c as s,a as n,o as t}from"./app-D8HvJIFE.js";const r={};function i(l,e){return t(),s("div",null,[...e[0]||(e[0]=[n(`<h1 id="_0-5px-问题" tabindex="-1"><a class="header-anchor" href="#_0-5px-问题"><span>0.5px 问题</span></a></h1><p>首先明确一点，就是非高清屏（即基本符合96ppi）上浏览器并不会进行缩放，也就没有“1px”问题 所以部分解决方案中要按需进行css媒体查询，根据设备dpr来区分是否需要解决“1px”问题 0.5px 这个方案原理比较简单，主要是看浏览器是否支持并能准确的显示小数值 该方案兼容性较差，实际可能还是按1px渲染 伪元素 + transform scale 原理分析 border无法直接利用transfrom来缩放，于是通过在元素上原本需要边框的位置添加一个宽或高为1px的伪元素来“冒充”边框，转而对该伪元素整体进行缩放 div::after { display: block; content: &#39;&#39;; height: 1px; // 通过scale变换，元素整体缩小一半 transform: scale(.5); }</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">伪元素 + 渐变背景色</span>
<span class="line">原理分析</span>
<span class="line">仍然是通过添加伪元素来“冒充”边框，再设置该伪元素背景为透明到有颜色的渐变，利用透明的部分背景使元素整体视觉效果变窄</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>div::after { display: block; content: &#39;&#39;; height: 1px; // 背景一半透明，一半黑色，视觉上缩小一半 background: linear-gradient(#000 50%, transparent 50%); }</p>`,4)])])}const p=a(r,[["render",i]]),c=JSON.parse('{"path":"/h5/0.5px%20%E9%97%AE%E9%A2%98.html","title":"0.5px 问题","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"h5/0.5px 问题.md"}');export{p as comp,c as data};
