import{_ as s,c as n,a as e,o as t}from"./app-D8HvJIFE.js";const p={};function c(o,a){return t(),n("div",null,[...a[0]||(a[0]=[e(`<h1 id="http016-http-fetch-发送两次请求的原因" tabindex="-1"><a class="header-anchor" href="#http016-http-fetch-发送两次请求的原因"><span>http016-HTTP fetch 发送两次请求的原因</span></a></h1><p>之所以会发送2次请求，那是因为我们使用了带预检(Preflighted)的跨域请求。该请求会在发送真实的请求之前发送一个类型为OPTIONS的预检请求。预检请求会检测服务器是否支持我们的真实请求所需要的跨域资源，唯有资源满足条件才会发送真实的请求。比如我们在请求头部增加了authorization项，那么在服务器响应头中需要放入Access-Control-Allow-Headers，并且其值中必须要包含authorization，否则OPTIONS预检会失败，从而导致不会发送真实的请求。</p><p>请求一次的是简单请求，两次的是非简单请求</p><h2 id="简单请求和非简单请求的区别" tabindex="-1"><a class="header-anchor" href="#简单请求和非简单请求的区别"><span>简单请求和非简单请求的区别</span></a></h2><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">请求的方法只能是<span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">HEAD</span>的一种</span>
<span class="line">请求的header的只能是Accept，Accept<span class="token operator">-</span>Language<span class="token punctuation">,</span> Content<span class="token operator">-</span>Language，Content<span class="token operator">-</span>Type这些字段，不能超出这些字段</span>
<span class="line">对于请求的header的Content<span class="token operator">-</span>Type字段，只能是以下值</span>
<span class="line"></span>
<span class="line">text<span class="token operator">/</span>plain</span>
<span class="line">multipart<span class="token operator">/</span>form<span class="token operator">-</span>data</span>
<span class="line">application<span class="token operator">/</span>x<span class="token operator">-</span>www<span class="token operator">-</span>form<span class="token operator">-</span>urlencoded</span>
<span class="line"></span>
<span class="line">都满足以上条件的就是简单请求，否则就是非简单请求。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如我们经常使用的Content-Type:application/json; charset=utf-8，这个请求就是非简单请求</p><h2 id="为什么需要预检请求" tabindex="-1"><a class="header-anchor" href="#为什么需要预检请求"><span>为什么需要预检请求</span></a></h2><p>发出预检请求针对的是非简单请求，这些非简单请求有可能会在服务器进行比较大的运算，增加负载，如果此时cors不通过，就有可能增加了服务器没有必要的运算，如果此时有预检请求，如果不通过，则真实请求不会发出，在一定程度上减少了服务器无效的运算。</p><h3 id="那为什么简单请求不需要预检呢" tabindex="-1"><a class="header-anchor" href="#那为什么简单请求不需要预检呢"><span>那为什么简单请求不需要预检呢？</span></a></h3><p>因为简单请求可以由form表单发起，它不是ajax请求，不涉及到跨域和cors问题，可以直接与服务器通信，另外，简单请求大部分上是获取资源比较多，运算也没那么复杂，所以进行一次预检请求就没有必要。</p><h2 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h2><blockquote><p>如果预检请求通过了，在一定时间内重复请求是不用再次发起预检请求。</p></blockquote>`,12)])])}const r=s(p,[["render",c]]),i=JSON.parse('{"path":"/http/http016-HTTP%20fetch%20%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0.html","title":"http016-HTTP fetch 发送两次请求的原因","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"http/http016-HTTP fetch 发送两次请求的原因.md"}');export{r as comp,i as data};
