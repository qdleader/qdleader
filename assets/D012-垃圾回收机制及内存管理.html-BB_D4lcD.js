import{_ as s,c as a,a as p,o as e}from"./app-D8HvJIFE.js";const t={};function o(c,n){return e(),a("div",null,[...n[0]||(n[0]=[p(`<h1 id="d012-垃圾回收机制及内存管理" tabindex="-1"><a class="header-anchor" href="#d012-垃圾回收机制及内存管理"><span>D012-垃圾回收机制及内存管理</span></a></h1><p>内存的生命周期:可以分为3个过程创建，使用，销毁</p><p><strong>内存的创建</strong>：（声明一个变量，对象，函数,数组，new一个构造函数等--- 都会在内存上开辟一个空间 <strong>内存的使用</strong>: 对于变量,对象等的一些操作，比如：赋值，累加求和，获取dom元素，并修改属性等等 <strong>内存的回收</strong>:不再使用的变量，会被js引擎自动回收（注意：全局变量是关闭页面后浏览器才会自动销毁,函数里面的变量，在函数调用完毕以后，自动销毁），所以垃圾就是指：不再使用的内存。 垃圾回收机制就是指：一个程序不再使用的内存（无用内存），Javascript 会找出不再使用的变量，不再使用意味着这个变量生命周期的结束。其会被js引擎‘自动回收’； 如果不能自动回收，就造成‘内存泄露’。</p><h2 id="一、垃圾回收机制详解" tabindex="-1"><a class="header-anchor" href="#一、垃圾回收机制详解"><span>一、垃圾回收机制详解</span></a></h2><p>1、什么是js的回收机制</p><p>垃圾回收机制的原理是找到不再继续使用的变量，释放其内存。垃圾回收器会按照固定的时间间隔(或代码中预定的收集时间)，周期性地执行这一操作; Javascript 会找出不再使用的变量，不再使用意味着这个变量生命周期的结束。Javascript 中存在两种变量——全局变量和局部变量，全局变量的生命周期会一直持续，直到页面卸载;而局部变量声明在函数中，它的生命周期从执行函数开始，直到函数执行结束。在这个过程中，局部变量会在堆或栈上被分配相应的空间以存储它们的值，函数执行结束，这些局部变量也不再被使用，它们所占用的空间也就被释放;</p><p>实例如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;qdleader&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;qdleader&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">   <span class="token keyword">return</span> obj<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p><p>垃圾回收的两种实现方式：标记清除、引用计数 2、标记清除(主流浏览器做法) 标记-清除： 这是JavaScript主要采用的垃圾回收算法。它分为两个阶段：</p><p>标记阶段： 垃圾回收器会从根部开始遍历所有的对象，标记所有能够被访问到的对象。 清除阶段： 垃圾回收器会清除未被标记的对象，释放它们占用的内存</p><p><strong>内部算法</strong> 垃圾回收的基本算法被称为 “mark-and-sweep”。</p><p>定期执行以下“垃圾回收”步骤：</p><p>垃圾收集器找到所有的根，并“标记”（记住）它们。 然后它遍历并“标记”来自它们的所有引用。 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。 ……如此操作，直到所有可达的（从根部）引用都被访问到。 没有被标记的对象都会被删除。</p><h5 id="增量标记-incremental-marking" tabindex="-1"><a class="header-anchor" href="#增量标记-incremental-marking"><span>增量标记（Incremental Marking）：</span></a></h5><p>（为了减少垃圾回收对应用程序的影响，一些现代浏览器实现了增量标记。增量标记将标记阶段分成多个小步骤，每执行一小步骤后，允许应用程序继续执行一些代码。这有助于分散垃圾回收器的工作负担，减少阻塞时间。）</p><p>3、引用计数(IE9以下)</p><p>含义是跟踪记录所有值被引用的次数;</p><p>例如变量a赋值后，这个值的引用次数为1，这个a值又被赋值给另一个变量b，这时引用次数+1;但当b赋另外的值，引用次数-1;当值的引用书为0，说明没有办法再访问这个值，这时就可以将内存回收了。</p><p>IE9以下还在使用引用计数，当对象循环引用时，引用次数无法标记为0，就会导致无法被回收。其他浏览器废弃使用;</p><p>下面的代码</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span> </span>
<span class="line">  <span class="token literal-property property">o2</span><span class="token operator">:</span> <span class="token punctuation">{</span> </span>
<span class="line">    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span> </span>
<span class="line">  <span class="token punctuation">}</span> </span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span> </span>
<span class="line"><span class="token comment">// 两个对象被创建。 </span></span>
<span class="line"><span class="token comment">// ‘o1’对象引用‘o2’对象作为其属性。 </span></span>
<span class="line"><span class="token comment">// 不可以被垃圾收集 </span></span>
<span class="line"><span class="token keyword">var</span> o3 <span class="token operator">=</span> o1<span class="token punctuation">;</span> <span class="token comment">// ‘o3’变量是第二个引用‘o1‘指向的对象的变量.  </span></span>
<span class="line">o1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 现在，在‘o1’中的对象只有一个引用，由‘o3’变量表示 </span></span>
<span class="line"><span class="token keyword">var</span> o4 <span class="token operator">=</span> o3<span class="token punctuation">.</span>o2<span class="token punctuation">;</span> <span class="token comment">// 对象的‘o2’属性的引用. </span></span>
<span class="line">                <span class="token comment">// 此对象现在有两个引用：一个作为属性、另一个作为’o4‘变量 </span></span>
<span class="line">o3 <span class="token operator">=</span> <span class="token string">&#39;374&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 原来在“o1”中的对象现在为零，对它的引用可以垃圾收集。 </span></span>
<span class="line">            <span class="token comment">// 但是，它的‘o2’属性存在，由‘o4’变量引用，因此不能被释放。 </span></span>
<span class="line">o4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// ‘o1’中最初对象的‘o2’属性对它的引用为零。它可以被垃圾收集。 </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二、js常见的内存泄漏" tabindex="-1"><a class="header-anchor" href="#二、js常见的内存泄漏"><span>二、Js常见的内存泄漏</span></a></h2><p>内存泄漏是应用程序过去使用，但不再需要的尚未返回到操作系统或可用内存池的内存片段。由于没有被释放而导致的，它将可能引起程序的卡顿和崩溃;</p><p>1、意外的全局变量</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">    bar <span class="token operator">=</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token comment">// window.bar = &quot;test&quot;; </span></span>
<span class="line"><span class="token punctuation">}</span> </span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>js对未声明变量会在全局最高对象上创建它的引用，(是以属性存在的，而不是变量)，如果在游览器上就是window对象，如果在node环境下就是global;如果未声明的变量缓存大量的数据，它可能只有在页面被刷新或者被关闭的时候才会释放内存，这样就造成了内存意外泄漏;</p><p>2、被忘记的定时器或者回调函数</p><p>我们以经常在 JavaScript 中使用的 setInterval 为例;</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">    <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;renderer&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">        renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token punctuation">}</span> </span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//每5秒执行一次. </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段显示了使用定时器引用节点或无用数据的后果。它既不会被收集，也不会被释放。无法被垃圾收集器收集，频繁的被调用，占用内存; 而正确的使用方法是，确保一旦依赖于它们的事件已经处理完成，就通过明确的调用来删除它们;</p><p>3、闭包 闭包是一个函数A返回一个内联的函数B,及时A函数执行完函数B也可以访问函数A里面的变量，这就是一个简单的闭包; 本质上闭包是将函数内部和外部连接起来的一座桥梁;</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">my</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">sendName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> </span>
<span class="line">    <span class="token punctuation">}</span> </span>
<span class="line">    <span class="token keyword">return</span> sendName </span>
<span class="line"><span class="token punctuation">}</span> </span>
<span class="line"><span class="token keyword">var</span> test<span class="token operator">=</span><span class="token function">my</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span> </span>
<span class="line"><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//test </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在my()内部创建的sendName()函数是不会被回收的，因为它被全局变量test引用，处于随时被调用的状态。如果向释放内存可以设置test=null;由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多</p><p>4、DOM泄漏</p><p>浏览器中DOM和js采用的是不一样的引擎，DOM采用的是渲染引擎，而js采用的是v8引擎，所以在用js操作DOM时会比较耗费性能，因为他们需要桥来链接他们。为了减少DOM的操作，我们一般将常用的DOM; 我们会采用变量引用的方式会将其缓存在当前环境。如果在进行一些删除、更新操作之后，可能会忘记释放已经缓存的DOM;</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span> </span>
<span class="line">    <span class="token literal-property property">button</span><span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;button&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span>
<span class="line">    <span class="token literal-property property">image</span><span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;image&#39;</span><span class="token punctuation">)</span> </span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span> </span>
<span class="line"><span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">    elements<span class="token punctuation">.</span>image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&#39;http://test.png&#39;</span><span class="token punctuation">;</span> </span>
<span class="line"><span class="token punctuation">}</span> </span>
<span class="line"><span class="token keyword">function</span> <span class="token function">removeImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">    <span class="token comment">// image 元素是body的直接子元素。 </span></span>
<span class="line">    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;image&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token comment">// 我们仍然可以在全局元素对象中引用button。换句话说，button元素仍在内存中，无法由GC收集 </span></span>
<span class="line"><span class="token punctuation">}</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一些优化建议" tabindex="-1"><a class="header-anchor" href="#一些优化建议"><span>一些优化建议：</span></a></h2><p><strong>分代收集</strong>（Generational collection）—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</p><p><strong>增量收集</strong>（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</p><p><strong>闲时收集</strong>（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响</p>`,41)])])}const i=s(t,[["render",o]]),r=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%E6%B1%87%E6%80%BB/D012-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"D012-垃圾回收机制及内存管理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1761877037000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"bd7640b59685e94edda53b9f6d34fbec27933dd4","time":1761877037000,"email":"yk4545945@163.com","author":"qdleader","message":"docs: 更新仓库链接和添加交流社区信息"}]},"filePathRelative":"前端面试/js类/常见面试题精选汇总/D012-垃圾回收机制及内存管理.md"}');export{i as comp,r as data};
