import{_ as i,c as a,a as n,o as s}from"./app-KfnfuIf0.js";const e={};function t(r,l){return s(),a("div",null,[...l[0]||(l[0]=[n(`<h1 id="数据类型及其区别" tabindex="-1"><a class="header-anchor" href="#数据类型及其区别"><span>数据类型及其区别</span></a></h1><p>八大数据类型</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">undefined</span>：变量未初始化</span>
<span class="line"><span class="token keyword">null</span>：空值或不存在的对象</span>
<span class="line">boolean：布尔值，<span class="token boolean">true</span> 或 <span class="token boolean">false</span></span>
<span class="line">number：可表示整数和浮点数，其中包含特殊值 <span class="token number">NaN</span> 与 <span class="token number">Infinity</span></span>
<span class="line">string：字符串</span>
<span class="line">symbol：创建唯一且不可变的值，主要用于对象属性的唯一标识，避免属性名冲突。（<span class="token constant">ES6</span> 新增）</span>
<span class="line">bigint：可表示任意精度的整数，允许操作超过 number 表示范围的整数。（<span class="token constant">ES6</span> 新增）</span>
<span class="line"></span>
<span class="line">object：对象，其中囊括了普通对象、数组以及方法。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><ul><li>原始数据类型： <ul><li>String</li><li>Number</li><li>Boolean</li><li>Null</li><li>Undefined</li><li>Symbol</li><li>BigInt</li></ul></li><li>引用数据类型： <ul><li>Object</li><li>Array</li><li>Function</li><li>Date</li><li>RegExp</li><li>Set</li><li>Map</li></ul></li></ul><h2 id="数据类型判断" tabindex="-1"><a class="header-anchor" href="#数据类型判断"><span>数据类型判断</span></a></h2><ul><li><p>typeof</p><ul><li>可以判断原始数据类型</li><li>可以判断函数</li><li>无法判断 null</li><li>无法判断对象</li></ul></li><li><p>instanceof</p><ul><li>可以判断对象类型</li><li>无法判断原始数据类型</li><li>无法判断 null</li><li>无法判断函数</li></ul></li><li><p>Object.prototype.toString.call()</p><ul><li>可以判断所有类型</li><li>无法判断 null</li><li>无法判断函数</li></ul></li><li><p>constructor</p><ul><li>可以判断所有类型</li><li>无法判断 null</li><li>无法判断函数</li></ul></li></ul><h2 id="数据类型转换" tabindex="-1"><a class="header-anchor" href="#数据类型转换"><span>数据类型转换</span></a></h2><ul><li>转换为字符串 <ul><li>toString()</li><li>String()</li><li>拼接字符串</li></ul></li><li>转换为数字 <ul><li>Number()</li><li>parseInt()</li><li>parseFloat()</li></ul></li><li>转换为布尔值 <ul><li>Boolean()</li><li>!!</li></ul></li><li>转换为对象 <ul><li>Object()</li></ul></li><li>转换为数组 <ul><li>Array.from()</li><li>Array.prototype.splice.call()</li></ul></li></ul><h2 id="基础-原始-类型-与-引用类型的区别" tabindex="-1"><a class="header-anchor" href="#基础-原始-类型-与-引用类型的区别"><span>基础（原始）类型 与 引用类型的区别</span></a></h2><p>存储位置区别</p><p>基本类型存储在 栈（stack） 中，值直接保存在变量访问的位置，由于其大小固定且频繁使用，存储在栈中具有更高的性能。 引用类型存储在 堆（heap） 中，占用空间较大且大小不固定，变量保存的是对实际对象的引用（即指针），这些引用存储在栈中。</p><h2 id="赋值区别" tabindex="-1"><a class="header-anchor" href="#赋值区别"><span>赋值区别</span></a></h2><p>基本类型：复制的是值本身。例如，将一个 number 类型的变量赋值给另一个变量，两个变量互不影响。- 值与值之间是独立存在的,比较时是按值比较</p><p>引用类型：复制的是指针。多个变量引用同一个对象时，一个变量的修改会影响其他变量。比较时是按引用比较</p>`,15)])])}const c=i(e,[["render",t]]),d=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/%E5%8F%98%E9%87%8F%E7%B1%BB/%E5%9F%BA%E7%A1%80%E7%B1%BB/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB.html","title":"数据类型及其区别","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1768183010000,"contributors":[{"name":"qdleader","username":"qdleader","email":"yk4545945@163.com","commits":1,"url":"https://github.com/qdleader"}],"changelog":[{"hash":"c3ab6d103d428cdd6a361e045add7154fc9253f1","time":1768183010000,"email":"yk4545945@163.com","author":"qdleader","message":"docs(mcp): 新增Mastergo MCP配置文档，包含token获取方法"}]},"filePathRelative":"前端面试/js类/变量类/基础类/数据类型及其区别.md"}');export{c as comp,d as data};
