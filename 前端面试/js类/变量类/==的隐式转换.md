# ==的隐式转换

类型相同的比较：

## （1）如果类型是 Undefined 或 Null，返回 true。
```js
null == null; // true
```

## （2）如果一个是 +0，另一个是 -0，返回 true：
```js
+0 == -0; // true
```

## （3）如果类型是对象，二者引用同一个对象，返回 true，反之返回 false。
```js
{} == {}; // false
```

null 和 undefined 比较： 仅当它们之间的比较时，返回 true。

```js
null == undefined; // true
```

NaN 比较： NaN 与任何值比较都返回 false，包括NaN自己。

```js
NaN == NaN;   // false

```

字符串与数字比较： 如果其中一个操作数是字符串，另一个是数字，将字符串转换为数字，然后进行比较。

```js
'5' == 5;   // true，将字符串 '5' 转换为数字 5 进行比较
```

布尔值与非布尔值比较： 布尔值无法直接比较，需先将布尔值转换为数字（true 转换为 1，false 转换为 0），非布尔值也需要转换成数字再比较。

```js
true == 1;  // true，将布尔值 true 转换为数字 1 进行比较
false == '123'; // false，将布尔值 false 转换为数字 0 ，将字符串 '123' 转换为数字 123 进行比较
```

对象与原始类型比较： 如果其中一个是对象，另一个是原始类型，将对象通过 ToPrimitive 转换为原始类型，然后进行比较。（即如果原始类型为字符串，则对象转换成字符串再比较；如果原始类为布尔值，则将布尔值与对象都转换成数字进行比较；如果原始类为数字，则将对象转换成数字进行比较。）

举个例子：
```js
{} == 1;  //false
```

ToPrimitive 在我的上篇文章（看了一天的官方文档，终于搞懂了 JS 类型转换机制）中详细介绍过，这里我们直接当做公式套用。

ToPrimitive(obj, Number) ==> Number({})

如果 obj 是基本类型，直接返回
否则，调用 valueOf 方法，如果得到原始值，则返回
否则，调用 toString 方法，如果得到原始值，则返回
否则，报错

首先{}先被ToPrimitive转换成字符串"[object Object]"，就相当于直接判断 "[object Object]" == 1，字符串与数字的比较中，又要将字符串转换成数字，"[object Object]"转换成数字为 NaN，而NaN 与任何值比较都为 false。
所以 {} == 1 返回 false。
